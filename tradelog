#!/bin/sh

export POSIXLY_CORRECT=yes
export LC_NUMERIC=en_US.UTF-8

print_help(){
echo "NAME"
  echo "     tradelog -- stock market log analyzer\n"
  echo "SYNOPSIS"
  echo "     tradelog [-h|--help]"
	echo "              [FILTER] [COMMAND] [LOG [LOG2 [...]]\n"
	echo "DESCRIPTION"
  echo "     The tradelog is script for stock market system record analysis. The script"
  echo "     filters records and provides statistics according to user input.\n"
  echo "The COMMAND can be one of:\n"
  echo "     list-tick"
  echo "             Print a list of occurring stock exchange symbols so-called \"ticks\".\n"
  echo "     profit"
  echo "             Print a statement of total profit from closed positions.\n"
  echo "     pos"
  echo "             Print a list of values of currently held positions sorted in"
  echo "             descending order by value.\n"
  echo "     last-price"
  echo "             Print a list of the last known price for each ticker.\n"
  echo "     hist-ord"
  echo "             Print a list of histogram of the number of transactions "
  echo "             according to the ticker.\n"
  echo "     graph-pos"
  echo "             Print a list of graph of values of held positions
             according to the ticker.\n"
  echo "The FILTER can be a combination of the following:\n"
  echo "      -a DATETIME
             After: only records after this date are considered (without
             this date). DATETIME is in the format YYYY-MM-DD HH:MM:SS.\n"
  echo "      -b DATETIME
             Before: only records BEFORE this date (without this date) are
             considered.\n"
  echo "      -t TICKER
             Only records corresponding to the given ticker are considered.
             With multiple occurrences of the switch, the set of all listed
             ticker is taken.\n"
  echo "      -w WIDTH
             Sets the width of the graph listing, ie the length of the
             longest line to WIDTH. Thus, WIDTH must be a positive
             integer. Multiple occurrences of the switch is a
             faulty start.\n"
  echo "      -h, --help
             Print help with a brief description of each command and switch.\n"
  echo "AUTHOR"
  echo "       Made by Vakhov Daniil | xvakho01"
  echo "                                         2021 Mar 30                                       "
}

t_func() {
  LOG_FILES=$(echo "$LOG_FILES" | awk -F ';' -v ticker="$TICKER" 'ticker~ $2";" {print}')
}
a_func() {
  LOG_FILES=$(echo "$LOG_FILES" | awk -F ';' -v after="$DATE_AFTER" '$1 > after {print}')
}

b_func() {
  LOG_FILES=$(echo "$LOG_FILES" | awk -F ';' -v before="$DATE_BEFORE" '$1 < before {print}')
}

list_tick_func() {
  LOG_FILES=$(echo "$LOG_FILES" | awk -F ';' '{print $2}' | sort -u)
}

profit_func() {
  PROFIT=$(echo "$LOG_FILES" | awk -F ';' '{
    if ($3=="sell")
    {
      q1+=+$4*$6
    }
    else
    {
    q2+=$4*$6
    }}
    END {printf("%.2f\n", q1-q2)
  }')
  echo "$PROFIT"
  exit 0;
}

pos_func() {
  LOG_FILES=$(echo "$LOG_FILES" | awk -F ';' '{print$2" "$1" "$6" "$4" "$3}' | sort -k1,2 |  awk '{
    if($6=="buy")
    {
      seen[$1]+=$4; lp[$1]=$5
    }
    else
    {
      seen[$1]-=$4; lp[$1]=$5
    }}
    END { for (i in seen)
    printf("%s:%.2f\n"), i, seen[i]*lp[i]}' | sort -n -t: -k2,2 | sed '1!G;h;$!d')

  longestNum=$(echo "$LOG_FILES" | awk -F  ":" '{
    num=sprintf($2)
    if(length(num) > longestNum)
    {
     longestNum=length(num)
    }
    } END {print longestNum
  }')

  LOG_FILES=$(echo "$LOG_FILES" | awk -F ":" -v lN="$longestNum" '{
    printf("%-9s : %*.2f\n", $1, lN, $2)
  }')
}

last_price_func() {
  LOG_FILES=$(echo "$LOG_FILES" | sed '1!G;h;$!d' | awk -F ";" '{print$2":"$4}' | sort -t: -u -k 1,1)
  longestNum=$(echo "$LOG_FILES" | awk -F  ":" '{
    num=sprintf($2)
    if(length(num) > longestNum)
    {
      longestNum=length(num)
    }
    } END {print longestNum
  }')
  LOG_FILES=$(echo "$LOG_FILES" | awk -F ":" -v lN="$longestNum" '{printf("%-9s : %*s\n", $1, lN, $2)}')
}

hist_ord_func() {
  LOG_FILES=$(echo "$LOG_FILES" | awk -F ';' '{print$2}'| sort | uniq -c | awk -v width="$WIDTH" '{
  count=sprintf($1);
  sy="#";
  if (width!=0 && int(count) > width)
  {
    count=width
  };
  str=sprintf("%*c",count,sy);
  gsub(" ",sy,str);
  printf("%-9s : %s\n", $2, str)
}')
}

graph_pos_func() {
  pos_func
  longestNum=$(echo "$LOG_FILES" | sed 's/ //g'| awk -F  ":" '
  function abs(x) {
    return(sqrt(x * x))
  }
  {
    num=sprintf($2)
   if(abs(num) > abs(longestNum))
  {
    longestNum=num
  }
  } END {print longestNum
  }')
  LOG_FILES=$(echo "$LOG_FILES" | sort -t: -k1,1 | sed 's/ //g'  |awk -F ":" -v width="$WIDTH" -v lN="$longestNum" '{
  if($2 < 0 )
  {
    sy="!"
  }
  else
  {
    sy="#"
  }
  if(width==0)
  {
    count=int($2/1000)
  }
  else
  {
    res=lN/width
    count=int($2/res)
  };
  if(count==0){
    printf("%-9s :\n", $1)
  }
  else{
  str=sprintf("%*c",count,sy); gsub(" ",sy,str); printf("%-9s : %s\n", $1, str)
 }}')
}

COMMAND=""
TICKER=""
DATE_BEFORE="9999-12-31 23:59:59"
DATE_AFTER="0000-00-00 00:00:00"
LOG_FILES=""
TFLAG=""
DAFLAG=""
DBFLAG=""
NOPTARG=""
WCOUNT=0
PROFIT=0.00
WIDTH=0

# test whether there is redirected input
if ! test -t 0; then
    RI_FLAG=1
    while IFS= read -r line; do
      LOG_FILES="$LOG_FILES$line\n"
    done
    # deleting the last "\n" empty line by the means of NF(number of fields in a line)
    LOG_FILES=$(echo "$LOG_FILES" | awk -F ';' '{ if (NF == 0) {next} else {print} }')
fi


while getopts w:t:a:b:h-: opts
do case "$opts" in
   a) DAFLAG=1
      NOPTARG=$(echo "$OPTARG" | sed 's/-//g ; s/://g ; s/ //g')
      NDATE_AFTER=$(echo "$DATE_AFTER" | sed 's/-//g ; s/://g ; s/ //g' )
      if [ $NOPTARG -gt $NDATE_AFTER ]; then
        DATE_AFTER="$OPTARG"
      fi ;;

   b) DBFLAG=1
      NOPTARG=$(echo "$OPTARG" | sed 's/-//g ; s/://g ; s/ //g')
      NDATE_BEFORE=$(echo "$DATE_BEFORE" | sed 's/-//g ; s/://g ; s/ //g' )
      if [ $NOPTARG -lt $NDATE_BEFORE ]; then
        DATE_BEFORE="$OPTARG"
      fi ;;
   t) TFLAG=1
      TICKER="$TICKER$OPTARG;";;
   w) WCOUNT=$(( $WCOUNT + 1 ))
      if [ "$WCOUNT" = 2 ]; then
          echo "Fail."
          exit 1;
      fi
      if [ $OPTARG -lt 0 ]; then
        echo "Fail."
        exit 1;
      else
        WIDTH="$OPTARG"
      fi;;
   h) print_help
      exit 0;;
   -) print_help
      exit 0;;
   *) echo "Invalid flag"
      exit 1;;
   esac
done

shift $(($OPTIND - 1))

while [ "$#" -gt 0 ]; do
  case "$1" in
  list-tick | profit | pos | last-price | hist-ord | graph-pos)
    COMMAND="$1"
    shift
    ;;
  *.log.gz)
    LOG_FILES="$LOG_FILES$(gzip -d -c "$1")\n"
    shift
    ;;
  *.log)
    LOG_FILES="$LOG_FILES$(cat "$1")\n"
    shift
    ;;
  *)
    echo "Invalid argument"
    exit 1
    ;;
  esac
done

LOG_FILES=$(echo "$LOG_FILES" | sed '/^$/d')

if [ "$TFLAG" = "1" ]; then
    t_func
fi
if [ "$DAFLAG" = "1" ]; then
    a_func
fi
if [ "$DBFLAG" = "1" ]; then
    b_func
fi
if [ "$COMMAND" = "list-tick" ]; then
    list_tick_func
fi
if [ "$COMMAND" = "profit" ]; then
    profit_func
fi

if [ "$COMMAND" = "last-price" ]; then
    last_price_func
fi

if [ "$COMMAND" = "hist-ord" ]; then
    hist_ord_func
fi

if [ "$COMMAND" = "pos" ]; then
   pos_func
fi

if [ "$COMMAND" = "graph-pos" ]; then
   graph_pos_func
fi
echo "$LOG_FILES"
exit 0
#2)Должен описовать зазнымы если не дано ни приказов ни фильтров при этом он может получить на вход не название файла
#а уже его содержимое
#4)Выволд ошбки если вызван препинач без параметров
#6) Закинуть все в функции отдельные
#10)Prognat po testam v 1001 raz
#11)Ubrat lishnie peremennye
#12)Naiti kak proverit rabotosposobnost na vsex shellax
#13)Proverit na merline
#14)Pri uspeshnom vzpolnenii uspeshniy kod vzponenia
#15)Сделать авторасширяемым и сужаемым хелп
#16)Как внутри скрипта сделать болд текст
